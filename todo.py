from fasthtml.common import *
from hmac import compare_digest
css = Style(':root { --pico-font-size: 100%; --pico-font-family: monospace;}')


db = database("data/todos.db")
todos = db.t.todos
users = db.t.users

if todos not in db.t:
    users.create(dict(name=str, pwd=str), pk='name')
    todos.create(id=int, title=str, done=bool, name=str, details=str, priority=int, pk='id')

Todo, User = todos.dataclass(), users.dataclass()

## AUTHENTICATION
# Any Starlette response class can be returned by a FastHTML route handler.
# In that case, FastHTML won't change it at all.
# Status code 303 is a redirect that can change POST to GET, so it's appropriate for a login page.
login_redir = RedirectResponse('/login', status_code=303)

# The `before` function is a *Beforeware* function. These are functions that run before a route handler is called.
def before(req, sess):
    # This sets the `auth` attribute in the request scope, and gets it from the session.
    # The session is a Starlette session, which is a dict-like object which is cryptographically signed,
    # so it can't be tampered with.
    # The `auth` key in the scope is automatically provided to any handler which requests it, and can not
    # be injected by the user using query params, cookies, etc, so it should be secure to use.
    auth = req.scope['auth'] = sess.get('auth', None)
    # If the session key is not there, it redirects to the login page.
    if not auth: return login_redir
    # `xtra` is part of the MiniDataAPI spec. It adds a filter to queries and DDL statements,
    # to ensure that the user can only see/edit their own todos.
    todos.xtra(name=auth)
    
    
bware = Beforeware(before, skip=[r'/favicon\.ico', r'/static/.*', r'.*\.css', '/login'])

def _not_found(req, exc): return Titled('Oh no!', Div('We could not find that page :('))


markdown_js = """
import { marked } from "https://cdn.jsdelivr.net/npm/marked/lib/marked.esm.js";
import { proc_htmx} from "https://cdn.jsdelivr.net/gh/answerdotai/fasthtml-js/fasthtml.js";
proc_htmx('.markdown', e => e.innerHTML = marked.parse(e.textContent));
"""

app = FastHTML(
    before=bware,
    exception_handlers={404: _not_found},
    hdrs=(
        picolink,
        css,
        # SortableJS('.sortable'),
        Script(markdown_js, type='module')
    ),
    live=True,
)

rt = app.route


@rt("/login")
def get():
    # This creates a form with two input fields, and a submit button.
    # All of these components are `FT` objects. All HTML tags are provided in this form by FastHTML.
    # If you want other custom tags (e.g. `MyTag`), they can be auto-generated by e.g
    # `from fasthtml.components import MyTag`.
    # Alternatively, manually call e.g `ft(tag_name, *children, **attrs)`.
    frm = Form(
        # Tags with a `name` attr will have `name` auto-set to the same as `id` if not provided
        Input(id='name', placeholder='Name'),
        Input(id='pwd', type='password', placeholder='Password'),
        Button('login'),
        action='/login', method='post')
    # If a user visits the URL directly, FastHTML auto-generates a full HTML page.
    # However, if the URL is accessed by HTMX, then one HTML partial is created for each element of the tuple.
    # To avoid this auto-generation of a full page, return a `HTML` object, or a Starlette `Response`.
    # `Titled` returns a tuple of a `Title` with the first arg and a `Container` with the rest.
    # See the comments for `Title` later for details.
    return Titled("Login", frm)

@dataclass
class Login: name:str; pwd:str

# This handler is called when a POST request is made to the `/login` path.
# The `login` argument is an instance of the `Login` class, which has been auto-instantiated from the form data.
# There are a number of special parameter names, which will be passed useful information about the request:
# `session`: the Starlette session; `request`: the Starlette request; `auth`: the value of `scope['auth']`,
# `htmx`: the HTMX headers, if any; `app`: the FastHTML app object.
# You can also pass any string prefix of `request` or `session`.
@rt("/login")
def post(login:Login, sess):
    if not login.name or not login.pwd: return login_redir
    # Indexing into a MiniDataAPI table queries by primary key, which is `name` here.
    # It returns a dataclass object, if `dataclass()` has been called at some point, or a dict otherwise.
    try: u = users[login.name]
    # If the primary key does not exist, the method raises a `NotFoundError`.
    # Here we use this to just generate a user -- in practice you'd probably to redirect to a signup page.
    except NotFoundError: u = users.insert(login)
    # This compares the passwords using a constant time string comparison
    # https://sqreen.github.io/DevelopersSecurityBestPractices/timing-attack/python
    if not compare_digest(u.pwd.encode("utf-8"), login.pwd.encode("utf-8")): return login_redir
    # Because the session is signed, we can securely add information to it. It's stored in the browser cookies.
    # If you don't pass a secret signing key to `FastHTML`, it will auto-generate one and store it in a file `./sesskey`.
    sess['auth'] = u.name
    return RedirectResponse('/', status_code=303)

# Instead of using `app.route` (or the `rt` shortcut), you can also use `app.get`, `app.post`, etc.
# In this case, the function name is not used to determine the HTTP verb.
@app.get("/logout")
def logout(sess):
    del sess['auth']
    return login_redir



def render_todo(todo):
    tid = f'todo-{todo.id}'
    toggle_done = A('‚úì' if todo.done else '‚óã', 
                    hx_post=f'/toggle/{todo.id}', 
                    target_id=tid,
                    style='cursor: pointer; text-decoration: none;')
    delete = A('üóëÔ∏è', hx_delete=f'/todos/{todo.id}', target_id=tid, hx_swap='outerHTML')
    return Tr(
        Td(toggle_done, style='width: 30px; text-align: center;'),
        Td(Span(todo.title, 
                style='font-weight: bold; cursor: pointer;',
                hx_get=f'/toggle_view/{todo.id}',
                target_id='current-todo',
                hx_swap='innerHTML')),
        Td(f'{todo.priority}', style='width: 100px; text-align: left;'),
        Td(delete, style='width: 30px; text-align: center;'),
        id=tid
    )

@rt("/", methods=["GET"])
def home():
    title = "To.do"
    top = Grid(H1(title), Div(A('logout', href='/logout'), style='text-align: right'))
    new_inp = Input(id="new-title", name="title", placeholder="New Todo")
    priority_inp = Input(id="new-priority", name="priority", type="number", placeholder="Priority", min="1")
    add = Form(
        Group(new_inp, priority_inp, Button("Add")),
        hx_post="/", target_id='todo-list', hx_swap="afterbegin"
    )
    
    todo_items = [render_todo(todo) for todo in todos(order_by='priority')]
    table = Table(
        *todo_items,
        id='todo-list', cls='sortable', hx_post="/reorder", hx_trigger="end",
        style='width: 100%;'
    )
    
    card = Card(table, header=add, footer=Div(id='current-todo'))
    
    return Title(title), Container(top, card)

@rt("/reorder", methods=["POST"])
def reorder(id: list[int]):
    for i, id_ in enumerate(id):
        todos.update({'priority': i + 1}, id_)
    return Table(*[render_todo(todo) for todo in todos(order_by='priority')], style='width: 100%;')

def clr_details():
    return Div(hx_swap_oob='innerHTML', id='current-todo')

@rt("/todos/{id}", methods=["DELETE"])
def delete(id: int):
    todos.delete(id)
    return clr_details()

@rt("/toggle/{id}", methods=["POST"])
def toggle(id: int):
    todo = todos[id]
    todo.done = not todo.done
    todos.update(todo)
    return render_todo(todo)

@rt("/edit/{id}", methods=["GET"])
async def get(id: int):
    res = Form(
        Group(Input(id="title"), Input(id="priority", type="number", min="1"), Button("Save")),
        Hidden(id="id"), CheckboxX(id="done", label='Done'),
        Textarea(id="details", name="details", rows=10),
        hx_put="/", target_id=f'todo-{id}', id="edit"
    )
    return fill_form(res, todos[id])

@rt("/", methods=["PUT"])
async def put(todo: Todo):
    todos.update(todo)
    return render_todo(todo), clr_details()

@rt("/", methods=["POST"])
async def post(todo: Todo):
    new_todo = todos.insert(todo)
    new_inp = Input(id="new-title", name="title", placeholder="New Todo", hx_swap_oob='true')
    new_priority = Input(id="new-priority", name="priority", type="number", placeholder="Priority", min="1", hx_swap_oob='true')
    return render_todo(new_todo), new_inp, new_priority

@rt("/todos/{id}", methods=["GET"])
async def get(id: int):
    todo = todos[id]
    btn = Button('delete', hx_delete=f'/todos/{todo.id}',
                 target_id=f'todo-{todo.id}', hx_swap="outerHTML")
    return Div(H2(todo.title), Div(todo.details, cls="markdown"), btn)

@rt("/toggle_view/{id}", methods=["GET"])
async def toggle_view(id: int, req):
    current_view = req.query_params.get('current_view', 'hidden')
    if current_view == 'hidden':
        return await view(id)
    else:
        return None # Return an empty string to clear the content

@rt("/view/{id}", methods=["GET"])
async def view(id: int):
    todo = todos[id]
    edit_btn = A('Edit', hx_get=f'/edit/{todo.id}', target_id='current-todo')
    close_btn = A('Close', 
                  hx_get=f'/toggle_view/{id}?current_view=visible', 
                  target_id='current-todo', 
                  hx_swap='innerHTML')
    return Div(
        Div(
            Span(f"Priority: {todo.priority}"),
            Span(f"Status: {'Done' if todo.done else 'Not Done'}"),
            edit_btn,
            close_btn,
            style="display: flex; justify-content: space-between; align-items: center; gap: 10px;"
        ),
        Hr(),
        Div(
            Div(f"**Description on {todo.title}**: {todo.details}", cls="markdown"),
        ),
        id='view-todo'
    )

serve()